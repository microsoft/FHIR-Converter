targetScope = 'subscription'

@minLength(3)
@maxLength(9)
@description('Used as the prefix to name provisioned resources where a custom name is not provided. Should be alphanumeric, at least 3 characters and no more than 9 characters.')
param serviceName string

@description('Location where the resources are deployed.')
@allowed([
  'australiaeast'
  'brazilsouth'
  'canadacentral'
  'canadaeast'
  'centralindia'
  'centralus'
  'chinanorth3'
  'eastasia'
  'eastus'
  'eastus2'
  'francecentral'
  'germanywestcentral'
  'japaneast'
  'koreacentral'
  'northcentralus'
  'northeurope'
  'norwayeast'
  'southafricanorth'
  'southcentralus'
  'southeastasia'
  'swedencentral'
  'switzerlandnorth'
  'uaenorth'
  'uksouth'
  'westeurope'
  'westus'
  'westus2'
  'westus3'
])
param location string

@description('Name of the resource group to deploy the resources to. If the resource group does not already exist, a new resource group will be provisioned with the given name or, if a name is not provided, with an autogenerated name based on serviceName.')
param resourceGroupName string = '${serviceName}-rg'

@description('Set to true to deploy a storage account for storing custom templates.')
param deployTemplateStore bool = false

@description('Name of storage account containing custom templates. If a name is not provided and deployTemplateStore is true, an autogenerated name based on serviceName will be used.')
param templateStorageAccountName string = deployTemplateStore ? '${serviceName}templatestorage' : '' 

@description('Name of storage account container containing custom templates. If a name is not provided and deployTemplateStore is true, an autogenerated name based on serviceName will be used.')
param templateStorageAccountContainerName string = deployTemplateStore ? '${serviceName}templatecontainer' : ''

@description('Name of the container app environment. If a name is not provided, an autogenerated name based on serviceName will be used.')
param containerAppEnvName string = '${serviceName}-app-env'

@description('Name of the container app to run the FHIR Converter service. If a name is not provided, an autogenerated name based on serviceName will be used.')
param containerAppName string = '${serviceName}-app'

@description('Minimum number of replicas for the container app.')
param minReplicas int = 0

@description('Maximum number of replicas for the container app.')
param maxReplicas int = 30

@description('CPU limit for the container app.')
param cpuLimit string = '1.0'

@description('Memory limit for the container app.')
param memoryLimit string = '2Gi'

@description('If set to true, security requirements will be enabled on the API endpoint.')
param securityEnabled bool = false

@description('Audiences for the api authentication.')
param securityAuthenticationAudiences array = []

@description('Authority for the api authentication.')
param securityAuthenticationAuthority string = ''

@description('If set to true, Application Insights logs and metrics collection will be enabled for the container app.')
param deployApplicationInsights bool = true

@description('The tag of the image to pull from MCR. To see available image tags, visit the [FHIR Converter MCR page](https://mcr.microsoft.com/en-us/product/healthcareapis/fhir-converter/tags)')
param containerAppImageTag string

var deploymentTemplateVersion = '1'

resource resourceGroup 'Microsoft.Resources/resourceGroups@2020-06-01' = {
  name: resourceGroupName
  location: location
  tags: {
    fhirConverterDeploymentTemplateVersion: deploymentTemplateVersion
  }
}

module templateStoreDeploy 'Deploy-TemplateStore.bicep' = if (deployTemplateStore) {
  name: 'templateStoreDeploy'
  scope: resourceGroup
  params: {
    location: location
    templateStorageAccountName: templateStorageAccountName
    templateStorageAccountContainerName: templateStorageAccountContainerName
  }
}

module convertInfrastructureDeploy 'Deploy-Infrastructure.bicep' = {
  name: 'convertInfrastructureDeploy'
  scope: resourceGroup
  params: {
    location: location
    envName: containerAppEnvName
    deployApplicationInsights: deployApplicationInsights
  }
}

module fhirConverterDeploy 'Deploy-FhirConverterService.bicep' = {
  name: 'fhirConverterDeploy'
  scope: resourceGroup
  params: {
    location: location
    appName: containerAppName
    envName: convertInfrastructureDeploy.outputs.containerAppEnvironmentName
    minReplicas: minReplicas
    maxReplicas: maxReplicas
    cpuLimit: cpuLimit
    memoryLimit: memoryLimit
    securityEnabled: securityEnabled
    securityAuthenticationAudiences: securityAuthenticationAudiences
    securityAuthenticationAuthority: securityAuthenticationAuthority
    templateStorageAccountName: deployTemplateStore ? templateStoreDeploy.outputs.templateStorageAccountName : templateStorageAccountName
    templateStorageAccountContainerName: deployTemplateStore ? templateStoreDeploy.outputs.templateStorageAccountContainerName : templateStorageAccountContainerName
    imageTag: containerAppImageTag
    applicationInsightsConnectionString: deployApplicationInsights ? convertInfrastructureDeploy.outputs.applicationInsightsConnectionString : ''
    applicationInsightsUAMIClientId: deployApplicationInsights ? convertInfrastructureDeploy.outputs.applicationInsightsUAMIClientId : ''
    applicationInsightsUAMIResourceId: deployApplicationInsights ? convertInfrastructureDeploy.outputs.applicationInsightsUAMIResourceId : ''
    containerAppEnvironmentId: convertInfrastructureDeploy.outputs.containerAppEnvironmentId
  }
  dependsOn: [
    templateStoreDeploy
    convertInfrastructureDeploy
  ]
}

output fhirConverterApiEndpoint string = fhirConverterDeploy.outputs.containerAppFQDN
output resourceGroupName string = resourceGroup.name
